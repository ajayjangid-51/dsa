//🔥💲🍕 As toh Now apn "Prims" and "Kruskals" algorithm or mtlb Method k bareh meh dekhenge which are about "Finding-Minimum-Cost-Spanning-Tree", mtlb apn "Minimum-cost-Spanning-Tree" find kr sktehh hai by following "Prims"-method or "Kruskals"-method.  🍕💲🔥
// As esseh toh apn ne yeh cheeze phle se "Graph-ds" meh study kr rhkhi hai, but now here apn in-short vapiss se re-call krenge enn cheezo ko, So toh first-of-all apn phle "Spanning-Tree" k bareh meh dekhenge and then yeh dekhenge ki "Minimum-Cost-Spanning-Tree" kya hota hai and kaise important hota hai and phir apn yeh algorithms( Prims and Kruskals) dekhenge for getting or Finding that "Spanning-Tree".

//🖼️🖼️🖼️  see pic-1 :- for seeing one of the Graph-example, as we that ki apn Graph ko represent ess tarah krtehh hai mtlb Graph is represented in terms of "V"(set-of-Vertexs) and "E"(set-of-Edges) for good visulization see pic-1. 🖼️🖼️🖼️
// 🥇🥇🥇:- As toh Spanning-Tree Graph ka "Sub-Part-Graph" hota hai and voh sub-Graph hota hai jismeh ek bhi "Cycles" nhi hoti. and as "Spanning-Tree" ko apn esseh formally bhi define kr sktehh hai ki "Spanning-Tree" is sub-Graph of a Graph, which includes all the "Vertices" but only (vertices - 1)-Edges.
//📔📔Note-point:- as toh NOw apn ek baat note krenge ki kisi bhi Graph se multiple "Spanning-Trees" ban sktehh hai, as q ki vaha there are many choices of selecting the (n-1)-Edges of the Graph.(where here "n" is "no.-of-vertexs").
//🖼️🖼️🖼️  see pic-2,3  :- for seeing the some of "Spanning-Trees" of the given Graph. 🖼️🖼️🖼️
// So toh Now aab essi baat se "Minimum-Cost-Spanning-Tree" define hota hai, as jaise upar just bhi apn ne note kiya ki there are multiple Spanning-Trees are possible, toh unn sbhi Spannig-Tree meh koi ek Tree toh jarur hoga jiski "Cost" Minimum hogi, whereas yaha "Cost" se mtlb hai ki agr "Edges"-ka-weight given ho, then sum-of-weight-of-all-Edges is known as "Cost" of "Spanning-Tree".

// as toh "Spanning-Tree" ko apn mathematically mtlb formulatically bhi define kr sktehh hai.. as like this ki "Spanning-Tree(S)" is a subSet of a given Graph, mtlb it is graph only , whereas its vertices are equal to actual-vertices but edges are equal to "(vertices-1)" (not (edges-1), as yeh wali baat apnko dhyn rkhni hai, as q ki kabhi-kabhi confusion ho jata hai... isiliy..)🖼️🖼️🖼️  see pic-4 and 5 for this.. 👆 🖼️🖼️🖼️

// 🥈🥈:- AS toh now apn given Graph k jo "Spanning-Trees" possible hai, unka Count find krna dekhenge mtlb yeh find krna dekhenge ki apn given "Graph" se kitne "Spanning-Trees" generate kr sktehh hai..
// thus toh according to generating of "Spanning-Tree" apnko available edges meh se (Vetices-1)-edges select krni hai or mtlb choose krni hai, toh mtlb yeh kaam edges~C~(v-1) tarike se kr sktehh hai, thus toh mtlb apn "no.-of-edges" k equal Spanning-Trees generate kr sktehh hai,(as bcoz {edges~C~(v-1) == edges} ),jaise from our example: apn 6~C~5 mtlb "6(six)" diff "Spanning-trees" bana sktehh hai.

//👿📔imp-Note-point:- as yeh baat apn importantly dekhenge ki agr jaise apne pass "pic-6" jaisa example ho, then phir vaha pe kitne no.-of-Spanning-trees possible hai from that "Graph", as forumla toh voh hi hoga, but apnko ek aur baat ka dhyn rkhna hai ki apnko yeh check krna hai ki "by-selecting-selecting-(vertices-1)-edges" Graph meh koi cycles ban rhi hai kya and agr ban rhi hai, then apnko voh sub-Graph ko as a "Spanning-Tree" nhi consider krna hai, nhi Count krna hai, mtlb apnko formulae-result meh se voh "no.-of-sub-graphs" subtract( mtlb minus ) krne hai.
// As mtlb apnko specifically voh "edge" dekhni hai jiski vajah se "cycle" ban rhi of "V-1"vertices (where here "V" is "no.-of-vertices").then apnko voh "Spannig-tree" ko consider krna hai mtlb actual total Count meh apnko usko substract krna hai. for this 🖼️🖼️🖼️  see pic-6 :- 🖼️🖼️🖼️

//💲🍕 Okay toh Now aab apn "Weighted-Graph(mtlb voh Graphs jiske edges ka weight assigned hota hai)" ka example lenge and esseh apn "Minimum-Cost-Spanning-Tree" define krenge...🖼️🖼️🖼️see pic-7🖼️🖼️🖼️🍕💲

// As toh "Minimum-Cost-Spanning-Tree" "Weighted-Graph" k "Spanning-Trees" meh se voh "Spanning-tree" hota hai, jiska "Weight( mtlb simply called as Cost )" sbse Minimum hota hai.
//🔔🔔 Thus toh now abse apna Focus mainly unn "Spanning-Trees" meh se "Minimum-Cost-Spanning-Tree" pe hi rhega, as q ki voh "Spanning-Tree" hi sbse important and usefull "Spanning-Tree" hai. So allover mtlb apnko given Graph meh se only "Minimum-Spanning-Tree" hi chahiyehh hai.
//🔔🔔 As toh mtlb aab baat yeh hai ki apn voh "Minimum-Cost-Spanning-Tree" kaise find kre.. thus toh eske liyeh:
//🥉naive-method-1: as naive method toh yeh hai ki apn phle sbhi possible "Spaning-trees" generate krlenge and saat meh unka Weight(mtlb Cost ) bhi calcuate kr lenge , and then unn meh se jis "Spanning-tree" ki Cost minimum hai usko hi choose krlenge as vohi toh apna "Minimum-Cost-Spanning-Tree" hai.

//🥇🥇🥇 Method2 yeh hai ki simply follow "Prims" or "Kruskals"-method( which is also a "Aglorithm" mtlb ess method ko apn "Code" kr sktehh hai mtlb "implement" bhi kr sktehh hai..) by which we can directly get that "Minimum-Cost-Spanning-Tree" (where yaha "directly" ka mtlb hai ki apnko voh sare spanning-trees find nhi krne honge mtlb sidhe directly we will get apna "minimum-spanning-tree" ). or yaa apn esseh bhi bol sktehh hai ki ess baat k liyeh "Prims" ne and "Kruskals" ne apne-apne alg-alg tarike baatehh mtlb algorithm suggest kiya ki haan ess tarah apn given Graph meh se directly, fastly and exactly "Minimum-Cost-Spanning-Tree" find kr sktehh hai.  🔔🔔
//💲🍕 Okay toh now aab apn "Prims" and "Kruskals"-algorithm dekhenge:- 🍕💲
// 🥇🥇🥇 Prim's-Algorithm:-
// AS toh according to Prim, apnko sbse phle sbse minimum-most-Costed-edge select krni hai, and then phir uss generate "Tree" meh jo vertices hai unseh connected jo edges hai unmehh se apnko minimum-most-Costed-Edge select krni hai and soo...on esseh krtehh rhena jab tk apnko esa lage ki ohh ek-aur "edge" select krne pr toh "cycle" ban rhi hai so toh mtlb we have to get stop at that point or mtlb for very easy-purpose apn esseh bhi bol sktehh hai stop at that when we have selected all the (Vertices-1)-edges. and thus toh now atlast apnko apna "Minimum-Cost-Spanning-Tree" mil jayegaa. (as yaha apn always apne generating-Tree se connected-edges meh hi minimum-most isily select krtehh hai takki apna generting-Tree "Tree" bana rhe as otherwise phir voh toh sayad non-connected banega and "Tree" non-connectec thodi hota hai. , so allover mtlb ki intially sbse phle select the smallest-edge and then phir always select the connected-smallest-edge.) 🖼️🖼️🖼️  for this see pic-8,9 and 10 :- 🖼️🖼️🖼️
//📔📔Note-point:- As aseh toh actual meh "Non-Connected-graph" ka specific sinlge "Minimum-Cost-spanning-Tree" define nhi hota, but phir vaha "Non-Connected-Graph" k liyeh har "component" k liyeh respecitive "Minimum-cost-Spanning-Tree" define hotehh hai.
//👿📔imp-Note-point:- as agr apne pass "Non-Connected-Graph" ho then, phir apn ess "Prim's"-method se apne "Graph" k har component k "Minimum-Cost-Spanning-Trees" find out nhi kr payenge, mtlb uss Graph k kisi only ek part ka "Minimum-Cost-Spanning-tree" hi find kr payenge , but baki parts ka nhi milega. thus toh mtlb apnko toh Graph k sare Components k "Minimum-Cost-Spanning-Trees" chahiyehh.
//🔔🔔 Thus toh allover mtlb ki "Prim's"-method se apn sirf only "Connected-Graph" ka hi "Minimum-Cost-Spanning-Tree" find kr sktehh hai. thus toh ess "drawback" ko remove krne k liyeh "Kruskal" ne apna algorith(metho) suggest kiya, thus toh mtlb aab apn "Kruskal"-algorithm dekhenge... 🔔🔔

// 🥇🥇🥇 Kruskal's-Algorithm:-
// AS toh according to Kruskal, apnko sbse phle sbse minimum-most-Costed-edge select krni hai and then soo..on sbse minimum-costed-edge krtehh rhena without taking care about that whether apni selecting-edge is one-among-the-connected-edge, toh mtlb apnko hamesa always minimum-most edge select krni hai. bas apnko itna dhyn rkhna hai "edge" select krne pr "cycle" nhi bnni chahiyehh, as agr ban "cycle" ban rhi ho, then skip the selection of that "edge", and move on the next-minimum-costed-Edge.
//👿📔imp-Note-point:- time-complexity of this algorith is O(V*E) , as q ki apn har baar minimum-most select kr rhe hai mtlb minimum-most find krke select kr rhe hai toh mtlb finding(mtlb searching ) it take O(n)-times and for finding for "E"-time total time is O(V*E) , where yaha "V" is no.-of-vertices and "E" is no.-of-edges for "Minimum-Spanning-Tree". 🖼️🖼️🖼️  see pic-11,12 :- 🖼️🖼️🖼️
// Now one-more 👿📔imp-baat ki apn ess Kruskals-algorithm k time ko orr decrease kr sktehh hai, by using the "Min-Heap" for storing the graph, so essa krne se kruskal's-aglo ki time-compelexity hojayegi equal to "O(nlogn)". 🖼️🖼️🖼️  see pic-13 :- so toh mtlb ess tarah apn kruskals-algorithm ko thoda aur faster bana sktehh hai. 🖼️🖼️🖼️
//🔔🔔 AS toh agr apn "kruskal"-algorithm ko "Non-Connected-Graph" pe apply krtehh hai, then vaha uss Graph k sare components k "minimum-spanning-tree" find ho bhi sktehh hai or nhi bhi ho sktehh.🖼️🖼️🖼️  see pic-14 :- 🖼️🖼️🖼️ 🔔🔔

//👿📔imp-Note-point:- this "prim"-algorithm and  "kruskal"-algorithm is used in such problems where we have to find the minimum-possible-Cost of "missing"-edges..
//🖼️🖼️🖼️  see pic-15 :- for seeing the example-problem for this 👆 baat. 🖼️🖼️🖼️

//🖼️🖼️🖼️  see pic-16,17 :- for example-problem of finding "MCST(minimum-cost-spannig-tree)"  🖼️🖼️🖼️
//👿📔imp-Note-point:- for any optimation-problem there will be only one-single-result but , ther for that result there may be multiple sets-of-solution. (as like here in this example there are 2-minimum-cost-spanning-trees) are possible but unki "Cost" ek hi hai. toh mtlb in general yeh wali baat apnko pata honi chahiyehh.

// 🥇🥇🥇 imp-baat ki yeh "Prims" and "kruskals" algorithms hai na, yeh actually "Greedy-method" se hi design kiyeh gayehh hai, mtlb "Prims" and "kruskals" ne apne-apne algorithm ko "Greedy-statergy" se hi design kiya hai, mtlb enhone "Greedy-Method" hi lagayii hai for doing this work(finding of "Minimum-spanning-tree").🥇🥇🥇
