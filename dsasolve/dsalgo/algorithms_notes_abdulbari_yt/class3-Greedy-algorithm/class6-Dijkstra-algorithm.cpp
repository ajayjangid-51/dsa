//🔥💲🍕 Single-Source-Shortest-Path-Problem:- 🍕💲🔥
// As yeh "Dijkstra"-Algorithm ess "Single-Source-Shortest-Path-Problem" k liyeh hai mtlb esko solve krne k liyeh hai , mtlb eska solution find krne k liyeh hai.

// Shortest-Path from any particular-fixed-node( as it also called "source-node" or "Source-Vertex") to all other vertices of the graph, mtlb ki apnko ek single-fixed-Source se Graph k har node ko visit krna hai by following a one-path and that path jo apn follow krne for visiting all the nodes, voh "Shortest-Path" hona chahiyehh.. as toh mtlb ess Problem meh apnko "Shortest-path" find krna hai mtlb it is optimization-problem and it is minimization-problem hai, toh mtlb esko apn "Greedy"-method se solve kr sktehh hai, and according to "greedy"-statergy apnko stages meh solve krna hota hai, mtlb har stage meh ek-cheez ko consider krna hota hai, and voh ek-cheez apni "Greedy"-nature k according hoti hai, mtlb agr apnko minimum-result chahiyehh, toh apn minimum-cheez ko consider krenge,, and so..on like this apna solution-set bana lenge..

//🔔🔔 Thus toh yeh "Dijkstra"-algorithm yeh Problem meh "Shortest-Path" find krne k liyeh hi hai, thus toh mtlb now aab apn yeh "Dijkstra"-algorithm ko hi dekhenge... 🔔🔔
// as toh phle apn ek simple basic cheez dekhenge jiske upar "Dijkstra"-algorithm designed hai.
// As toh sbse phle apn 3-vertexed-graph lenge (🖼️🖼️🖼️  as shown in pic-1 :- 🖼️🖼️🖼️), now the task is this ki apnko from Source-vertex(A) se vertex(B) and vertex(C) ka shortest-path find krna hai, thus toh sbse phle apnko enn Vertex(B) and verex(C) k liyeh agr koi "direct"-path-hai-from-vertex(A) hai then mark the distance-Cost onto the that "vertex" and agr shortest-path nhi hai, then mark the distance as "infinity" for that node and then follow "Dijkstra"-algorithm so toh according to "Dijkstra", apnko phir always sbse phle sbse shortest-distance pe jo node(mtlb vertex) hai usko select krna hai... and phir uss "Vertex" pe aake, again uss "vertex" jo vertex sbse shortest-distance pe hai, usko select krna hai, consider krna hai and uss "vertex" ki distance agr "infinity"-define hai then update that "distance" by its "shortest-distance". and soo..on repeat this upto we find the "shortest-paths" for requested-vertices from the "Source-Vertex".
// As toh yaha pe apn "greedyness" dekh sktehh hai, thus isiliy it is designed as per "Greedy"-method.
//👿📔imp-Note-point:- as toh apn ne yaha yeh cheez bhi dekhli ki "Greeady" meh apn har possible case consider krke usmeh suitable solution find nhi krtehh hai, vaha apn directly apni "greedyness" k according minimum or maximum-most case consider krke aage badhtehh hai.

//📔📔Note-point:- as "Dijkstra"-algorithm is applicable to "Directed" as well as "Non-Directed"-Graph.
// 🥈🥈 "Relaxation" mtlb ki jab apn infinity-marked-Node ko uski actual-shortest distance se update krtehh hai then this updation is called as "Relaxation" mtlb infinity-marked-Node thoda aab Relax ho gaya hai ki in the manner ki phle apnne usko infinity-distance pe mark kr diya thaa, but in actual voh infinity-distance pe thaa hi nhi, toh mtlb aab updation by actual-shortest-distance se voh node aab "Relax" feel kr raha hai.for this 🖼️🖼️🖼️  see pic-2 :- 🖼️🖼️🖼️, toh jaise mtlb if(u+d < v), then update "v" by "u+d".
//👿📔imp-Note-point:- as yaha "Dijkstra"-algorithm meh ek baat "Greedy"-baat hai ki always select "shortest"-path-algorithm , and other kuch baateh jaise phle intially "direct-path"-vertices and "non-direct-path"-vertices ki distance mark krna, and then phir after selecting shortest-distanced-Vertex, phir accordingly relaxation krna etc..etcc. , thus toh yaha pe yeh intially-working and yeh relaxation-krna yeh "greedy"-nature se krne wali baat nhi hai, but yaha ek baat hai jo ki "greedy-nature" ki baat hai, thus toh algorithm meh kam-se-kam ek-baat hone pr bhi apn esseh boltehh hai ki yeh algorithm ess "statergy" k upar designed hai, in real sabhi problems meh sirf only "statergy" apply krke apn uska solution nhi find kr sktehh hai, as apnko thoda aur kuch phir kuch additional-baateh bhi sochni hoti hai, jaise yaha "Dijkstra" ne socha ki intially-do-this and then after doing-accordingly-greedy do the relaxation etc..etc.. things to get the Result.👿📔

//🔔🔔 So, toh now aab apn yeh "Dijktra"-algorithm follow krenge for solving this example-problem (🖼️🖼️🖼️  see the problem in pic-3 🖼️🖼️🖼️), as for this problem the Source-vertex is vertex(1) and ess problem meh apnko sbhi sare "Vertices" k liyeh Shortest-path find krne hai.. 🔔🔔
// So toh sbse phle toh apn "direct-path"-Vertices and "indirect-path"-Vertices ki distance-labelling kr deni hai, and phir apna "Dijkstra"-algorithm follow krna hai, mtlb intially from the "Source-Vertex" se shortest-distanced-Vertex ko select krna hai, and phir uss Vertex pe move hoke then vaha uss Vertex ko as "u" and usseh connected-Vertices ko one-by-one "v" mantehh huyehh "Relaxation" krna hai. and then again selecing the next-shortest-distanced-Vertex from the "Source-Vertex"-only.
//🖼️🖼️🖼️  see pic-4 and 5 :- for seeing the whole-Dijkstra-procedure for calculating the "Shortest-Distances" 🖼️🖼️🖼️
//👿📔imp-Note-point:-as NOw aab apn ess Procedure ko thoda time k liyeh analize kre , toh mtlb yeh ess procedure meh apn cycle meh shortest-path find kr rhe hai and phir Relaxation bhi kr rhe hai, thus toh mtlb apn har cycle meh atmost "v"-vertices ko relax krtehh hai, and apni no.-of-cycles depend krti hai on the no.-of-vertices thus toh total-time will be Orderof(v*v) mtlb O(v^2) or O(n^2) , where here "v" or "n" mtlb no.-of-vertices. as this worst-case-time hai. ( yeh apan priori-analysis hai from the algorithm not from the program , as program se bhi same hi hoga, as difference toh postreori-testing meh hota hai.)

//💲🍕 Okay toh now aab apn ek Common-textbook-example-problem lenge of single-Source-shortest-path-Problem-type , and espeh apn from sctrach se "Dijktra"-algorithm apply krenge.. and solution get krenge.. 🍕💲 🖼️🖼️🖼️  see pic-6 :- for seeing the Problem-statement and  for solution of this problem, 🖼️🖼️🖼️ ,

//👿📔imp-Note-point:- As yeh upar phle apnne jo example dekha tha voh, toh about "UnDirected-Graph" k bareh meh tha and yeh problem hai about "Directed-Graph" , thus toh "Directed-graph" k liyeh apnko ek-baat- alg se dhyn rkhni hai ki apn jo "Relaxation" krtehh hai voh sirf connected-vertices ka hi krna hai, whereas yaha Connected ka mtlb ki link-direction-uss-Vertex-pe-point krni chahiyehh, as then only it means ki voh vertices connected hai. 👿📔
//👿📔imp-Note-point-2:- as agr koi "Vertex"-already selected hai then usko apnko vapis se check nhi krna hai, as q ki agr apn check bhi krtehh hai , then there will no use of that bcoz usko krne se koi farak nhi padega.
//👿📔imp-Note-point-3:- as after getting the solutin kisi "Vertex" ki distance "infinity" rheti hai, then mtlb we cannot reach that "Vertex" in anyway, mtlb even not following "shortest-Path".
//📔📔Note-point-4:- as toh apn "Non-Directed-Graph" ko bhi "Directed-graph" meh convert kr sktehh hai, by just simply replacing the edge by "parallel-directed-edges".

//🔔🔔 AS toh Now aab apn "Dijkstra"-algorithm ka Drawback dekhenge.. 🔔🔔
// As toh yeh apna "Dijkstra"-algorithm tab kaam nhi krta jab apne "Graph" meh edges ka weight "negative" ho.see this ,🖼️🖼️🖼️  see pic-7 :- 🖼️🖼️🖼️ for such kind of Graph. as yaha "-negative." ka mtlb yeh nhi hai ki yeh edge distance ko hi represent kr rhi hai, as mtlb yeh distance k alava bhi kuch bhi ho skti hai,, as mtlb jaise business-problems bhi as graph hi represent hoti hai, and mtlb many more problem ko apn as graph draw krke explain kr sktehh hai or samaj sktehh hai, toh mtlb thus isiliy "Graph" ki kafi applications hai. q ki kafi problems ko apn drawing krke samaj sktehh hai and drawing mtlb voh "Graph" hi hai , thus toh agr apnko usko implement krna hai then toh usko apn as-it-is "Graph-ds" meh implement bhi kr sktehh hai, toh usko phir "graph" meh hi implement kr detehh hai.
// Thus toh "Dijkstra" ne Graph meh "-negative"-values k liyeh kuch socha nhi, now toh agr apn yeh "Dijkstra"-algorithm Graph having negative-weight-edges pe apply then
// so toh mtlb ess example pe toh "Dijkstra" - algorithm kaam kr gaya, but agr espe apn thoda change kre then apn yaha realize krenge,, ki apn ne upar ek baat conclude ki thi agr-koi-Vertex-visited hai then usko vapis se visit krne ki koi jarurat nhi hai, but yaha apn ne realize kiya ki jarurat toh hai in "negative-graphs",
//🖼️🖼️🖼️  see pic-8 :- 🖼️🖼️🖼️. as jaise upr phle apnne yeh conclude kiya tha ki apn phle B-vertex ka shortest-path as weight-of-"3" find kiya tha but after again we get that its can be "-3"-also if we follow that path.
// So toh allover apn yeh bol sktehh hai ki "Dijkstra"-algorithm may or may not work on "negative-Graphs".

//📔📔Note-point:- as toh ess algorithm k "Drawback" ko remove krdiya gaya by "Bellman-Ford" by giving his "Algorithm",as this "Bellman-Ford"-aglorithm , jo ki "dynamic-Programming-statergy" se design kiya gaya hai, banaya gaya hai.📔📔