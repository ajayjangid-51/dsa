//ğŸ”¥ğŸ’²ğŸ• Okay toh Now aab YAHA pe apn "Dynamic-Programming" k bareh meh dekhenge,,, as "Dynamic-Programming" ek type of "Statergy" hai, ek "Method" hai, ek "approach" hai, ek "tarika" for solving the Optimization-Programming-problems, thus toh all simple boleh toh "DP" is Algorithm-design-technique, mtlb yeh "technique" hai jisseh apn such kind of "Programming-Problem" k liyeh "algorithm" design kr sktehh hai, and agr apnne algorithm design krliya then mtlb yeh toh sure hogaya ki apn usko phir implement bhi kr sktehh hai, mtlb code kr sktehh hai, mtlb code krke usko automate kr sktehh hai, as actual apna objective "Automation" hi krna hota hai. ğŸ•ğŸ’²ğŸ”¥

//ğŸ’²ğŸ• As YAHA pe apn ek cheez aur dekhenge that is "Principle-of-Optimality" , mtlb ki "Optimality" ka principle kya hai, mtlb jo apni "Optimization"-problem ka "Optimal"-solution hota hai, usko find krne ka koi "Principe", thus toh apn yehi Principle dekhenge...

//ğŸ‘¿ğŸ“”imp-Note-point:- AS "Dynamic-programming" bhi "Optimization"-Problems ko solve krne k liyeh hoti hai.

// AS toh YAHA pe apn phle toh "Dynamic-Programming" k bareh meh dekhenge ki yeh kya hoti hai kaise hoti etcc.etcc. and then phir "DP" and "Greedy" k bich meh difference dekhenge. and phir apn "Memoization" and "Tabular" k bich meh meh difference dekhenge ki yeh "Memoization" kaise hota hai and yeh "Tabular" kaise hota hai and enko apn compare bhi krenge ki konsa accha hai mtlb "Memoization" accha hai ya "tabulation" accha hai.

//ğŸ””ğŸ”” Okay, toh now phle apn "Dp" and "Greedy" k bich meh difference dekhenge... ğŸ””ğŸ””
// As jaise ki apn jantehh hi hai ki "Greedy" and "Dp" dono hi "Optimization"-problem ko solve krne liyeh hi use hoti hai. as aseh toh yeh dono ek-dam different "statergies" hai, but enka purpose same hai , mtlb dono "Optimization"-problem ko solve krne k liyeh hi hai.
// As "greedy" meh toh apn "pre-defined"-procedure follow krtehh hai, jaise ki for getting maximum-result we always select or choose maximum-valued-case and for getting Minimum-result we always select minimum-valued-case. thus toh "greedy" meh toh yeh esi "procedure" ko "optimal-procedure" boltehh hai and esko follow krne se apnko apna "optimal"-solution bhi mil jata hai. , but in "Dynamic-programming" meh apn phle all possible-solutions find krtehh hai and unmeh se phir best-solution mtlb "optimal-solution" pick kr letehh hai, as toh isiliy phir yeh "Dp"-approach "Greedy" se thodi jada time-consuming ho jati hai. and mostly "Dp"-problem ko apn mostly recursively formula se solve krtehh hai, mtlb recursion-function ka use krtehh hai for getting all the possible-solutions, as mtlb apn problem ko recursive-formula banake(see cp-book-example for understanding this very clearly ) , consider k solve krtehh hai, but usko apn implement "Recursion" meh nhi krtehh hai, as uss "recursive"-formulae ko implement ko apn "iteratively" hi krtehh hai, mtlb "loop" se hi implement krtehh hai. And ek-aur important baat ki "Dp"-approach "Principle-of-optimality" ko follow krti hai, whereas "Principle-of-Optimality" yeh hai ki apnko optimization-problem ko solve krne k liyeh apnko sequence-of-decisions lene hoteh hai, where "decisions" are about "getting the optimal-solution".
// Now yaha pe apn point "highlight" krenge ki jaise "Greedy" meh toh apn ek-baar meh hi decision leleteh hai that ki apn always minimum-most or maximum-most choose krenge , whereas "Dynamic-programming" meh apn esseh nhi krtehh hai, as mtlb apn multiple times "decisions" leteh hai mtlb har stage meh "decision" leteh hai ki haan aab aseh krenge , now aseh krenge.. and soo...on like this upto getting "optimal-solution". as toh yeh "decision" lene wali cheez apn aage ek example-problem leke samajenge..

// ğŸ¥‡ğŸ¥‡ğŸ¥‡ now imp-baat ki jaise apn nen abhi kaha ki "Dp" thodi slow ho jati hai, as bcoz apn yaha sare solutions find krtehh hai and then unmeh se accordingly "optimal"-solution choose kr letehh hai aur ya "optimal"-solution choose krke next or upper-stage meh move ho jatehh hai. Thus toh "Dp" ka consumption-time kaam krne k liyeh "Dp" meh 2-cheeze aur define hoti hai:- 1st. "Memoization" and 2nd. "Tabulation" :-

//ğŸ””ğŸ”” Okay toh Now aab apn "Memoization" and "Tabulation" k bareh meh dekhenge ki kaise hoteh hai, as yeh q hotehh hai yeh toh apn ne dekh liya hai ki yeh "Dp" ki time-complexity ko kaam krne k liyeh hai. And ek-baat aur ki apn enn dono meh se kisi ko follow krtehhh hai. ğŸ””ğŸ””

// ğŸ¥ˆğŸ¥ˆ Memoization:- ğŸ¥ˆğŸ¥ˆ
//ğŸ–¼ï¸ğŸ–¼ï¸ğŸ–¼ï¸  see pic-1 :- for seeing the fibonacci-problem ğŸ–¼ï¸ğŸ–¼ï¸ğŸ–¼ï¸, as yeh fibonacci-problem ko apn "dc"-concept se solve kr sktehh hai, as q ki espeh "Dc" ka concept lgta hai ki requested-term ka result can be found from its last-term and 2nd-last-term, thus toh mtlb agr "Dc"-concept lgta hai toh uss problem ko apn recursively-implement kr sktehh hai and recursivelly implement kr sktehh hai toh mtlb uss "Recursion" ko apn as a "recursive-formulae" meh bhi likh sktehh hai, and agr apn kisi problem ka solution "Recursive-formulae" meh likh sktehh hai then phir toh mtlb usko apn "Dp" se solve kr sktehh hai, mtlb phir agr apn uss "Recursive-formulae" pe "memoization" or "tabulation" laga de toh mtlb voh apni "Dp"-approach hojayegi. So toh Now as per the Problem, apn ne "recursive-formula" bana liya hai for solving this problem. and agr apne pass "recursive-formula" hai then phir usko apn easily "Recursion" meh implement kr sktehh hai and apna kaam easily hojayega, but agr apn esko analize kre eska time kafi jada hoga mtlb it is O(n^2) mtlb yeh toh kafi slow hai(//ğŸ–¼ï¸ğŸ–¼ï¸ğŸ–¼ï¸  see pic-2,3,4 :- for seeing the working and time-taken of this implementation.ğŸ–¼ï¸ğŸ–¼ï¸ğŸ–¼ï¸ and ğŸ–¼ï¸ğŸ–¼ï¸ğŸ–¼ï¸  see pic-5 :- for time-complexity of this function, as ess recursive-fn ka time apnne "recurrence-relation" se find krliya hai, as like by assumig that ki let total-time is T(n) , which will equal to recursive-call which is 2T(n-1) , so toh mtlb recurrence-relation is T(n)=2T(n-1), so toh now after solving this recurrence-relation by simply according to "Master's-theorm" we get the time-of-this-recursive-fn is O(2^n), as time-esseh thodasa little kaam hoga, bcoz function it was f(n-2), esko apn as big-O kr rhe hai then phir koi issue nhi hai.Thus toh overall mtlb apna yeh algorithm toh kafi time lega mtlb "exponential"-time le raha hai, as agr apn ğŸ¥‡ğŸ¥‡ğŸ¥‡ yaha thoda sahi se dekhe ki yeh algorithm itna time q le rha hai ,then yaha apn ek cheez notice krenge ki jaise fib(1) 5-times call huaa hai, fib(2) 3-times call huaa hai, fib(3) 2-times call huaa hai(ğŸ–¼ï¸ğŸ–¼ï¸ğŸ–¼ï¸see pic-6 for this thingğŸ–¼ï¸ğŸ–¼ï¸ğŸ–¼ï¸), thus toh baat yeh hai ki apn ek hi function ko multiple times q call kr rhe hai, mtlb apn uss function ki value kahi store krle and then jab yeh function call hove toh simply voh stored-value hi apn consider kr sktehh hai na, Thus toh esa krna hi is known as "Memoization" krna hai or "Tabulation" krna. as "memoization" and "tabulation" meh itna hi farak hai ki "tabulation" meh "table" banake usmeh "storing" krtehh hai and "Memoization" meh  ),Thus toh Now agr apn esko "Dp"-approach se implement kre, as "Dp"-approach se implement krne k liyeh phle apne pass problem-ko-solve krne ka "Recursive-formula" hona chahiyehh jo ki apne pass hai, thus toh mtlb apn esko kr sktehh hai "Dp" se. thus toh now apnko bas espeh "Memoziation" or "tabulation" lagake esko solve krlenge.. so Toh Now apn phle "Memoization" lagayenge, So toh apn phle simply ek global-array lenge and ess global-array ko apn "-1" se intialize krdenge.. and apn recursive-fn meh recursive-call ess global-array ko dekh k krenge.. ki jaise agr recursive-call-parameter ki value k equal index pe value kya hai , as if it is "-1" then we will make that recursive-call and after this recursive-call over apn ess recursive-call ki value uss global-array meh uss index pe store krdenge and or agr if it is other then "-1" then apn recursive-call nhi krenge as simply uss recursive-call ess index-value se replace krdenge.. and soo..on yeh krtehh rhenge till we get our result. Thus toh yeh procedure of using the "globla-array" and making the "recursive-call" as per this "array" is only called "Memoization"-process, as mtlb apn function-call ka result store krke phir same function ka vapis call hone ko rok rhe hai, So toh allover time-of-function reduce ho jata hai.
//ğŸ–¼ï¸ğŸ–¼ï¸ğŸ–¼ï¸  see pic-7,8,9 :- for seeing this procedure of "memoization" ğŸ–¼ï¸ğŸ–¼ï¸ğŸ–¼ï¸, and ğŸ–¼ï¸ğŸ–¼ï¸ğŸ–¼ï¸  see pic-10 :- for time-analysis of this algorithm which is O(n), thus toh apn yaha Notice kr sktehh hai ki "Dp"-statergy se algorithm design krne se apn ne ess problem ko O(n)-time meh hi krliya hai.. joki kafi huge difference hai, mtlb phle apn jis algorithm se kr rhe the, voh toh exponential-time le raha tha, but "Dp"-idea se algorithm banane pe apne algorithm ka time O(n) mtlb linear-time meh ho gaya hai, jo mtlb kafi acchi and mast baat hai and yeh itna differece toh ess example meh aaya hai, but agr apn other problems ki baat kre then , vaha pe bhi kuch-na-kuch toh difference aayega hi bcoz of the applied "Dp"-statergy. ğŸ–¼ï¸ğŸ–¼ï¸ğŸ–¼ï¸
//ğŸ‘¿ğŸ“”imp-Note-point:- "Memoization follow "top-down-approach" , "top-down"-approach mtlb jo solution-answer hai voh top se find hona start hota hai and atlast down meh jake vaha se solution-collect hona start hota hai.".
//ğŸ–¼ï¸ğŸ–¼ï¸ğŸ–¼ï¸  see pic-11 :- for seeing the view of this "top-down"-approach. ğŸ–¼ï¸ğŸ–¼ï¸ğŸ–¼ï¸
// ğŸ¥‡ğŸ¥‡ğŸ¥‡ AS but "Dynamic-programming" meh apn "memoization" use nhi hota, as mtlb "Dp" meh apn tabulation" use krtehh hai, as q ki "Memoization" ko "recursion"-friendly hai  and "tabulation" "iterative"-friendly hai, thus toh "Dp"-algorithm ko apn iteratively implement krtehh hai , toh isiliy apn phir usmeh "tabulation" ka use krtehh hai. Okay toh now aab apn esi problem ko "Dp" se and "Dp" meh "tabulation" se krna dekhenge..
//ğŸ–¼ï¸ğŸ–¼ï¸ğŸ–¼ï¸  see pic-12, 13 :- for seeing the procedure of doing this Problem iteratively and using "Tabulation" ğŸ–¼ï¸ğŸ–¼ï¸ğŸ–¼ï¸, as toh overall mtlb ki "tabulation" meh table(or mtlb "list") generate hoti hai by our "iterative-fn" and phir atlast voh function generated "table" or mtlb "list" meh se required "value" return kr deta hai.
//ğŸ“”ğŸ“”Note-point:- as this "tabulation" is bottom-up approch , as mtlb q ki value(result) get krna start hota hai from "0th-index"-of-"list or table or array".
//ğŸŒŸğŸŒŸğŸŒŸ  Thus toh overall ess tarah, apn "Dp"-apporach se jo algorithm apn sochtehh  hai usko apn esseh implement krtehh hai mtlb via using "loop" and "tabulation" apn implementation krtehh of the our "dp"-algorithm :- ğŸŒŸğŸŒŸğŸŒŸ
// ğŸ¥ˆğŸ¥ˆ as esseh agr apn chahyeh toh apn "Dp"-approach ko "recursively" bhi implement kr sktehh hai, but voh phir vaha pe thode complications ho jatehh hai, as q ki apnko phir Recursion meh "Memoization" use krna hota hai mtlb jaise phir recursion-fn meh apnko conditional-recursive-call rkhni hogi, and then kafi savdhani se apnko "global-array" ko fill up krna hoga , thus toh isiliy apn "itervatively" implement krtehh hai q ki "iteratively"-implement krna kafi easy ho jata hai for performing "tabulation"-method in that.

// ğŸ¥‡ğŸ¥‡ğŸ¥‡ Okay toh important baat yeh hai ki apnko bas "Dp"-approach mil jani chahiyehh, as ek baar approach , idea mil gaya, then usko phir apn easily implement kr sktehh hai in "iteratively" with "tabulation", and "Dp"-approach yehi hai ki sbse phle "recursive-formula" construct kro, then phir useh "itervatively"-with-tabulation implement krdo.
// Okay toh now aab aage apn esi cheez pe focus krenge ki apn kaise yeh "recursive-formulae" banayeh about the given-problem. by taking example-problems.
