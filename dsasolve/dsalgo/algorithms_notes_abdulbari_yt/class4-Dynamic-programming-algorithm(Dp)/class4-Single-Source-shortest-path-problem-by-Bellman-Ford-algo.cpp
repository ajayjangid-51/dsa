//ğŸ”¥ğŸ’²ğŸ• Okay toh Now YAHA pe apn apni voh "Single-Source-Shortest-Path-Problem" ko "dp" se solve krna dekhenge.. jo ki actually sbse phle "Bellman-Ford" ne kiya thaa, and phir essi algorithm se "dynamic-programming(dp)"-statergy role meh aayi. mtlb "bellman" ne hi yeh "dp"-statergy mtlb "fast-programming"-statergy suggest ki thi. thus toh mtlb apn yeh "bellman-Ford"-algorithm algorithm hi dekhenge.. but usseh phle apn thoda khud se sochenge... ki according to "dp" apn ess problem ko kaise krnegee, as q ki "dp"-statergy toh apn ne phle hi dekhli hai.      ğŸ•ğŸ’²ğŸ”¥

// now toh ess problem k liyeh apna idea toh yeh hoga ki apn ess problem as like "All-pairs's-Shortest-path-problem" ki tarah bhi solve nhi kr sktehh hai, as q ki vaha toh apn sbhi "pairs" ko consider krke apna algo design kiya tha..

// As toh NOw apn "bellman-Ford"-algorithm dekhenge.. and atlast ess "bellman-Ford"-algorithm ka drawback bhi dekhenge..
// As toh apn ess problem ko jantehh hi hai ki , apne pass ek "vertex" as a "Source-Vertex" hoga and apnko uss "Source"-vertex se sare vertices pe jane ka "Shortest-path" find out krna hai.
//ğŸ””ğŸ”” (as yeh Multistage-problem se diff hai, as q ki "multistage"-problem meh toh apnko sirf source-to-Sink pe jane ka shortest-path find out krna thaa, and as yaha apnko sare vetices (except "source"-vertex) pe jane ka shortest-paths find out krne hai. ) ğŸ””ğŸ””
// as yeh "Bellman"-algorithm more prefably unn Graph k liyeh hai jinki edges ka weight "negative" hota hai, toh mtlb aseh Graphs pe apn "dijkstra"-algo lagatehh hai, then vaha apne pass koi Conformation nhi hai ki apnko "correct-result" milega, so toh isiliy apn phir "Bellman"-algorithm use krtehh hai. and yeh "Bellman"-algo is designed per the "dp"-statergy, and apn jantehhh hi hai ki "dp"-statergy k according apn sbhi possible-solutions find krtehh hai, and then unmeh se best-solution pickup kr letehh hai. as toh cheez apn tabhi bhi krtehh hai jab apn "recursive-formula" phle desing krtehh hai and then table ko fill krtehh hai, as toh apn table fill krtehh hai na , toh  mtlb usmeh apn sare possible-cases k solutions fill krtehh hai, toh mtlb actually apn yehi kaam kr rhe hai ki "dp" meh apn sare possible-solutions ko consider krtehh hai, as sare-possible-solutions mtlb sub-problem k sare-possible-solutions. toh mtlb baat yeh hai ki apn problem ko phle sub-problem meh break krtehh hai, and then uss sub-problem k jo possible-solutions hai unmeh se best (mtlb minimum  or maximum) select kr letehh hai. mtlb jaise apn phle main-problem ko possible sub-problems meh select krtehh hai and unn sub-problems meh se jiska solution best(mtlb minimum or maximum) hoga usko choose kr letehh hai, but unn sub-problems ka solution find krne k liyeh apn phir se unn sub-problems ko unke-unke respective sub-problems meh break-down krtehh hai.. and soo..onn esa krtehh rhetehh , krtehh rheteh hai jab tk apn fundamental-sub-problems pe na puch jayehh.. and phir vaha se apna solution build-up hona chula ho jata hai in upward-direction apnko solution mil jata hai, thus toh mtlb yeh ess aseh kaam toh apn "recursively" implement kr sktehh hai. thus toh allover isiliy "dp" yeh bolti hai ki phle problem ko "recursively" krna socho, and then "recursive-formula" banaao.. and then phir "memoization" ya "tablulation" ka use krlo and "table" ko fill krlo and then simply main-problem ka result return krdo from the table or ya agr apnko voh particular "combination" pucha hai then simply follow "principle-of-optimality" mtlb take decisions-in-sequence and return that result.

// Thus toh allover main baat yeh hai ki apnko problem ko uski just-sub-problems meh break krna aana chahiyehh, mtlb apne pass idea hona chahiyehh ki haan agr meh esa krunga then phir yeh sub-problem define hojayegi, jaise apnne "LCS"-problem meh sub-problem ess way meh consider ki thi ki agr first-characters match ho jatehh hai then apnko voh utni strings toh leni hi nhi hai, toh mtlb yaha apn ne problem ko chota kr liya na or mtlb problem ko sub-problem find kr li hai mtlb subproblem meh break kr liya hai, and agr first-characters equal nhi hotehh hai, toh mtlb apn dono character meh se ek character ko skip kr sktehh hai, but kisko kre toh voh apn decide krenge on the basis of minimum-result or maximum-result thus toh isiliy apn dono ko leletehh hai and unmeh se best(mtlb yaha maximum mtlb longest consider krlenge.. ) and ek ğŸ“”ğŸ“”Note-point: ki apn sub-problems ko actual-problem se create krna hi start krtehh hai , mtlb vase hi krna chahiyehh mtlb aseh nhi ki apn directly hi given-problem ki fundamental-sub-problem find krne meh lage hai , jo ki easily possible nhi hai in many of the cases ki jaise fibo meh possible hai as q ki apn phle se hi fundamental-sub-problem( mtlb "recursion" ki bhasa meh it is called as "base-case" mtlb jiske baad meh apn recursive-call nhi krtehh. ) jantehh hai ki O! ki value 1 hai, and 1! ki value 1 hai, and apn yeh bhi jantehh hai ki yeh fibonacci-terms sub-problems meh kaise break hoti hai, as yeh ess way meh break hoti hai ki it is sumation of fibo(n-1)+fibo(n-2). but yaha "lcs" meh yeh directly find krna possible nhi hai ki ess problem meh fundamental-sub-problem kya hogi, and problem-ki-sub-problems-kya-hogi, thus toh esiliy "dp" yeh khti hai ki aap initialy sbse phle problem ki just-possible-sub-problems find kro and then esa krtehh hai , krtehh hai fundamental-sub-problem pe pucho..toh mtlb yeh legit tarika hai for getting the "recursive-algorithm" or mtlb "recursive-formula". then phir accoringly apnko "tabulation" ka use krlena hai.. mtlb apni table ko simply accordingly recursive-formula se fill kr lena hai, and at the end result(solution) return kr dena hai.
// ğŸ¥ˆğŸ¥ˆ toh mtlb apnko sirf simply given problem ki just-sub-problem pe focus krna hai, and mtlb voh usko(given problem) ko uski just-sub-problems meh kaise break kre.. and many times apnko condition bhi di hoti hai, ki koi bhi output esseh construct hota hai, toh mtlb jis cheezo se voh construct ho rha hai, or mtlb ho sktaa hai vohi uski sub-problem hai. thus toh bas phir usko apn simply recursive-formula meh likh sktehh hai.
// ğŸ¥‡ğŸ¥‡ğŸ¥‡ toh bas allover "dp" yehi hai, now bas apnko more-and-more problem-practice krke sikha na hai ki given "problem" ko uski just-sub-problems meh kaise usko break krtehh hai. jaise for coin-change-problem , lcs-problem etc..etc.. sb meh yeh hi important hai ki apn given-problem ki just-sub-problems kaise find kre... as agr apn yeh kaam kr leteh hai, then all thing is all easy to do to get answer. :-
//ğŸ“”ğŸ“”Note-point:-  "Optimal-substructure" maane problem ka answer problem-ki-just-sub-problems se aana. and "Optimal-subStructure"-property mtlb agr problem ka solutio uski just-sub-problems se find ho sktaa hai then apn boltehh hai ki this problem has a "Optimal-subStructure-Property", so we can solve it "dynamically" mtlb "fastly" via "dp"-statergy.

//ğŸ’²ğŸ• Now solving this problem,,, as per "bellman"-algo mtlb as per "dp"-statergy. ğŸ•ğŸ’²
// as yaha apnko multiple solution find krne hai mtlb vertex-2 k liyeh shortest-path from vertex-1 , vertex-3 k liyeh shortest-path and as like this vertex-4, vertex-5 .. upto vertex-n. thus mtlb apn esseh kr sktehh hai ki phle apn vertex-2 ko tackle krenge.. thus toh now apn vertex-2 pe vertex-1 and vertex-3 se aa sktehh hai. and now yaha pe vertex-1 and vertex-3 as a sub-problem hogi gayi hai, toh mtlb now apn phle vertex-1 and vertex-3 se tackle krenge.. and enmeh se minimum-chosse krlenge (as this condition is like this:-           Shortpath(2) = min(shortpath(1) , shortpath(3)) )so toh vertex-1 ka fundamental-sub-problem hojayegi q ki apn vertex-1 pe kisi aur vertex se nhi aa sktehh. thus toh eska result toh "0" hi hoga and eske "vertex-1" k return meh vertex-1-edge-weight aayega. , mtlb vetex-1 se vertex-1 pe aane ka shortest-path toh "zero"-lenght ka hoga. so toh apn aab "vertex-3" pe move hojayenge, so toh vertex-3 pe apn vertex-1 and vertex-4 pe aajyenge.. so toh apn minimum of these 2-lenge.. and so now then we will first tackle with vertex-4 and so , as like this..
// toh mtlb yaha pe apnne sare-possible-cases try kiyeh in this way ki jaise apne vertex-2 k liyeh dekha toh vaha apn ne dekha ki apn vertex-2 pe all possibly kaise-kaise puch sktehh hai, thus toh mtlb yeh esseh all possible-cases apne consider kiyeh hai ,and unmeh se best(mtlb minimum) select kiya hai.

// So this "bellman"-algorithm says that apnnko vertices(mtlb as "edges" ko ) ko "n-1"-times tk relaxation krtehh rhena hai.
// (where here "n" is no.-of-vertices.) ğŸ–¼ï¸ğŸ–¼ï¸ğŸ–¼ï¸  see pic-1 :- ğŸ–¼ï¸ğŸ–¼ï¸ğŸ–¼ï¸
// as toh sbse phle apnko sbhi vertices ko as at a "infinity"-distance mark kr dena hai,, and then edges ko one-by-one lena hai( as apn edges ko koi bhi order meh le sktehh hai.) and then "n-1"-times relaxation krna hai. ğŸ–¼ï¸ğŸ–¼ï¸ğŸ–¼ï¸  see pic-2 :- ğŸ–¼ï¸ğŸ–¼ï¸ğŸ–¼ï¸
//ğŸ–¼ï¸ğŸ–¼ï¸ğŸ–¼ï¸  see pic-3 :- for 1st-time relaxation ğŸ–¼ï¸ğŸ–¼ï¸ğŸ–¼ï¸
//ğŸ–¼ï¸ğŸ–¼ï¸ğŸ–¼ï¸  see pic-4 :- for 2nd-time-relaxation ğŸ–¼ï¸ğŸ–¼ï¸ğŸ–¼ï¸
//ğŸ–¼ï¸ğŸ–¼ï¸ğŸ–¼ï¸  see pic-5 :- for 3rd-time-relaxation ğŸ–¼ï¸ğŸ–¼ï¸ğŸ–¼ï¸
//ğŸ–¼ï¸ğŸ–¼ï¸ğŸ–¼ï¸  see pic-6 :- for 4th, 5th, 6th-time-relaxation ğŸ–¼ï¸ğŸ–¼ï¸ğŸ–¼ï¸
// as toh jaise yaha after 3rd-cycle relaxation hona stop hogaya, toh mtlb kuch "Graphs" meh after 1st-cycle bhi relaxation hona stop ho skta hai and kuch "Graphs" meh at last cycle meh "relaxation" hona stop ho skta hai. thus toh apn overall time-complexity ki baat kre for this "bellman-algorithm" is O(E*V)( whereas "E" is no.-of-edges and "V" is no.-of-vertices) and we can also say that time is O(n^2).
// "Complete-Graph" mtlb voh "Graph" jismeh har vertices-pair k bich meh atleast one(1)-edge toh ho hi. so toh complete-Graph meh edges hoti hai n(n-1)/2, so toh ess "bellman"-algo ki "Complete-graph" k liyeh time-complexity hogi O(n^3), //ğŸ–¼ï¸ğŸ–¼ï¸ğŸ–¼ï¸  see pic-7 :- for seeing time-complexities.. ğŸ–¼ï¸ğŸ–¼ï¸ğŸ–¼ï¸

// ğŸ¥‡ğŸ¥‡ğŸ¥‡ so toh by both method apnko apna result same hi mila hai, toh mtlb dono method sahi hai and both are as per the "dp"-approach only.

//ğŸ””ğŸ”” Okay toh now aab apn "Bellman-ford" ka drawback dekhenge.. by taking an example-problem:- ğŸ””ğŸ””.
//ğŸ–¼ï¸ğŸ–¼ï¸ğŸ–¼ï¸  see pic-8 :- (for seeing the problem-example) ğŸ–¼ï¸ğŸ–¼ï¸ğŸ–¼ï¸
//ğŸ–¼ï¸ğŸ–¼ï¸ğŸ–¼ï¸  see pic-9(for 1st-cycle) , pic-10,11 (for 2nd-cycle and 3rd-cycle) :- ğŸ–¼ï¸ğŸ–¼ï¸ğŸ–¼ï¸
//ğŸ””ğŸ”” now apn ess example meh ek little change krenge... ğŸ””ğŸ””,ğŸ–¼ï¸ğŸ–¼ï¸ğŸ–¼ï¸  see pic-11 :-for seeing that little-change.. ğŸ–¼ï¸ğŸ–¼ï¸ğŸ–¼ï¸, as toh ess example k according toh apna "M1" and "M2" dono hi kaam nhi krenge.. as q ki "M1" meh toh "infinite-recursion" ban jayega and "M2" meh after the "v-1"-cycles relaxation stop nhi hoga.. mtlb voh "infinite" tk stop nhi hoga.( ğŸ–¼ï¸ğŸ–¼ï¸ğŸ–¼ï¸  see pic-12 :- to this "infinitely"-relaxation  and pic-13-and-14 to see our M1.ğŸ–¼ï¸ğŸ–¼ï¸ğŸ–¼ï¸.). So toh actual baat yeh hai ki apn esko manully bhi nhi kr sktehh hai q ki ess "Graph" meh cycle ban rhi hai.
//ğŸ–¼ï¸ğŸ–¼ï¸ğŸ–¼ï¸  see pic-13 :- to see the cycle-formed-in-the-Graph. and actual baat yeh hai ki agr formed-Cycle ka net-weight "negative" hai, then yeh apna "Bellman"-ford kaam nhi karega. and apna "M1" toh sirf simple Cycle-hogi tabhi kaam nhi karega.. toh mtlb "M1" and "M2" meh "M2(bellman)" hi jeet taa hai. as q ki "M2" toh cycle-with-positive-net-weight meh toh kaam karega but apna "M1" cycle-with-positive-net-weight meh bhi kaam nhi karega. ğŸ–¼ï¸ğŸ–¼ï¸ğŸ–¼ï¸
// ğŸ¥‡ğŸ¥‡ğŸ¥‡ So toh yaha "Bellman-algorithm" ka "Drawback" as a important situation meh kaam aata hai, ki agr apnko yeh check krna ho ki given "Graph" meh "negative-net-weight-cycle" hai kya, then apn "Bellman"-algo lagake yeh find kr sktehh hai.:-

// problem given hoti hai mtlb ek target given hota hai, thus toh mtlb apnko uss target ki just-sub-problem se start krna hai.
